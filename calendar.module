<?php
define('CALENDAR_SHOW_ALL', 0);
define('CALENDAR_HIDE_ALL', -1);

/**
 * @file
 * Adds calendar filtering and displays to Views.
 */

/**
 * Implements hook_views_api().
 */
function calendar_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'calendar') . '/includes',
  );
}

/**
 * Calendar display types.
 */
function calendar_display_types() {
  return array('year' => t('Year'), 'month' => t('Month'), 'day' => t('Day'), 'week' => t('Week'));  
}

/**
 * Implementation of hook_help().
 */
function calendar_help($section, $arg) {
  switch ($section) {
    case 'admin/help#calendar':
      return t("<p>View complete documentation at !link.</p>", array('!link' => 'http://drupal.org/node/120710'));
  }
}

/**
 * Implements hook_theme().
 */
function calendar_theme() {
  $module_path = drupal_get_path('module', 'calendar');

  $base = array(
    'file' => 'theme.inc',
    'path' => "$module_path/theme",
  );
  return array(
    'calendar_datebox' => $base + array(
      'template' => 'calendar-datebox',
      'variables' => array(
        'date' => NULL, 'view' => NULL, 'items' => NULL, 'selected' => NULL),
      ),
    'calendar_empty_day' => $base + array(
      'variables' => array('curday' => NULL, 'view' => NULL),
      ),
    'calendar_stripe_legend' => $base + array(
      'variables' => array('stripe_labels' => NULL),
      ),
    'calendar_stripe_stripe' => $base + array(
      'variables' => array('node' => NULL),
      ),
    'calendar_time_row_heading' => $base + array(
      'variables' => array('start_time' => NULL, 'next_start_time' => NULL, 'curday_date' => NULL),
      ),
    'calendar_month_col' => $base + array(
      'template' => 'calendar-month-col',
      'variables' => array('item' => NULL),
      ),  
    'calendar_month_row' => $base + array(
      'template' => 'calendar-month-row',
      'variables' => array('inner' => NULL, 'class' => NULL, 'iehint' => NULL),
      ),    
    );
}

/**
 * Implements hook_node_view().
 *
 * Add link to calendar to nodes, formerly hook_link().
 * Controlled by value of 'calendar_date_link' in the view.
 */
function calendar_node_view($node, $view_mode, $langcode) {
  $path = variable_get('calendar_date_link_' . $node->type);
  if (!empty($path)) {
    $links['calendar_link'] = array(
      'title' => t('Calendar'),
      'href' => $path,
      'attributes' => array('title' => t('View the calendar.')),
    );
    $node->content['links']['calendar'] = array(
      '#theme' => 'links__node__caledar',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

/**
 * Formats the weekday information into table header format
 *
 * @ingroup event_support
 * @return array with weekday table header data
 */
function calendar_week_header($view) {
  $len = isset($view->date_info->style_name_size) ? $view->date_info->style_name_size : (!empty($view->date_info->mini) ? 1 : 3);
  $with_week = !empty($view->date_info->style_with_weekno);

  // create week header
  $untranslated_days = calendar_untranslated_days();
  if ($len == 99) {
    $translated_days = date_week_days_ordered(date_week_days(TRUE));
  }
  else {
    $translated_days = date_week_days_ordered(date_week_days_abbr(TRUE));
  }
  if ($with_week) {
    $row[] = array('header' => TRUE, 'class' => "days week", 'data' => '&nbsp;');
  }
  foreach ($untranslated_days as $delta => $day) {
    $label = $len < 3 ? drupal_substr($translated_days[$delta], 0 , $len) : $translated_days[$delta];
    $row[] = array('header' => TRUE, 'class' => "days " . $day, 'data' => $label);
  }
  return $row;
}

/**
 * Array of untranslated day name abbreviations, forced to lowercase
 * and ordered appropriately for the site setting for the first day of week.
 *
 * The untranslated day abbreviation is used in css classes.
 */
function calendar_untranslated_days() {
  $untranslated_days = date_week_days_ordered(date_week_days_untranslated());
  foreach ($untranslated_days as $delta => $day) {
    $untranslated_days[$delta] = strtolower(substr($day, 0, 3));
  }
  return $untranslated_days;
}

function calendar_groupby_times($type = '') {
  $times = array();
  switch ($type) {
    case 'hour':
      for ($i = 0; $i <= 23; $i++) {
        $times[] = date_pad($i) . ':00:00';
      }
      break;
    case 'half':
      for ($i = 0; $i <= 23; $i++) {
        $times[] = date_pad($i) . ':00:00';
        $times[] = date_pad($i) . ':30:00';
      }
      break;
    default:
      break;
  }
  return $times;
}

/**
 * Create a stripe.
 *
 * @param $node - the node object
 * @param $query_name - the views queryname for this date field
 * @param $delta - the delta for this field, used to distinguish fields that appear more than once in the calendar
 * @param $stripe - the hex code for this stripe.
 * @param $label - the label to give this stripe.
 * 
 * TODO Reconsider use of $GLOBALS as a method of triggering the legend, there
 * may be a better way.
 */
function calendar_node_stripe($view, &$node, $query_name, $delta, $stripe = NULL, $label = '') {
  $colors = isset($view->date_info->calendar_colors) ? $view->date_info->calendar_colors : array();
  if (empty($colors)) {
    return;
  }
  if (empty($node->raw->node_type)) {
    return;
  }

  $type_names = node_type_get_names();
  $type = '';
  $type = $node->raw->node_type;
  if (!(isset($node->stripe))) {
    $node->stripe = array();
    $node->stripe_label = array();
  }  
  if (!$label && array_key_exists($type, $type_names)) {
    $label = $type_names[$type];
  }
  if (!$stripe) {
    if (array_key_exists($type, $colors)) {
      $stripe = $colors[$type];
    }
    else {
      $stripe = '';
    }
  }

  $node->stripe[] = $stripe;
  $node->stripe_label[] = $label;
  $GLOBALS['calendar_stripe_labels'][][$type] = array('stripe' => $stripe, 'label' => $label);
  return $stripe;
}

 /**
 * Create a stripe based on a taxonomy term.
 *
 * @param $node - the node object
 * @param $query_name - the views queryname for this date field
 * @param $delta - the delta for this field, used to distinguish fields that appear more than once in the calendar
 * @param $stripe - the hex code for this stripe.
 * @param $label - the label to give this stripe.
 * 
 * TODO Reconsider use of $GLOBALS as a method of triggering the legend, there
 * may be a better way.
 */

function calendar_node_taxonomy_stripe($view, &$node, $query_name, $delta, $stripe = NULL, $label = '') {
  $colors_taxonomy = isset($view->date_info->calendar_colors_taxonomy) ? $view->date_info->calendar_colors_taxonomy : array();
  if (empty($colors_taxonomy)) {
    return;
  }

  if (empty($node->raw->taxonomy_term_data_tid)) {
    return;
  }

  // Rename the vid added by Views to the normal name that 
  // taxonomy will expect, it's in the raw results.
  $node->vid = $node->raw->node_vid;

  $terms_for_node = (array) $node->raw->taxonomy_term_data_tid;
  if (!(isset($node->stripe))) {
    $node->stripe = array();
    $node->stripe_label = array();
  }
  if (count($terms_for_node)) {
    foreach ($terms_for_node as $tid) {
      $term_for_node = taxonomy_term_load($tid);
      if (!array_key_exists($term_for_node->tid, $colors_taxonomy)) {
        continue;
      }
      $stripe = $colors_taxonomy[$term_for_node->tid];
      $stripe_label = $term_for_node->name;
      $node->stripe[] = $stripe;
      $node->stripe_label[] = $stripe_label;
      $GLOBALS['calendar_stripe_labels'][][$term_for_node->tid] = array('stripe' => $stripe, 'label' => $stripe_label);
    }
  }
  else {
    $node->stripe[] = '';
    $node->stripe_label[] = '';
  } 
  return;
}

/**
 * Create a stripe based on group.
 *
 * @param $node - the node object
 * @param $query_name - the views queryname for this date field
 * @param $delta - the delta for this field, used to distinguish fields that appear more than once in the calendar
 * @param $stripe - the hex code for this stripe.
 * @param $label - the label to give this stripe.
 * 
 * TODO Reconsider use of $GLOBALS as a method of triggering the legend, there
 * may be a better way.
 */
function calendar_node_group_stripe($view, &$node, $query_name, $delta, $stripe = NULL, $label = '') {
  $colors_group = isset($view->date_info->calendar_colors_group) ? $view->date_info->calendar_colors_group : array();
  if (empty($colors_group)) {
    return;
  }
  if (!function_exists('og_get_node_groups')) {
    return;
  }

  $groups_for_node = og_get_node_groups($node);
  if(!(isset($node->stripe))){
    $node->stripe = array();
    $node->stripe_label = array();
  }
  if (count($groups_for_node)){
    foreach($groups_for_node as $gid => $group_name){
      if (!array_key_exists($gid, $colors_group)) {
        continue;
      }
      $stripe = $colors_group[$gid];
      $stripe_label = $group_name;
      $node->stripe[] = $stripe;
      $node->stripe_label[] = $stripe_label;
      $GLOBALS['calendar_stripe_labels'][][$gid] = array('stripe' => $stripe, 'label' => $stripe_label);
    }
  }
  else {
    $node->stripe[] = '';
    $node->stripe_label[] = '';
  } 
  return $stripe;
}

/**
 * Helper function to figure out a group gid to use in blocks.
 *
 * @return an array of group nodes that are relevant.
 * @todo this may need more work.
 */
function calendar_og_groups($view) {
  if (!$groupnode = og_get_group_context()) {
    global $user;
    $groupnodes = array_keys($user->og_groups);
  }
  else {
    $groupnodes = array($groupnode->nid);
  }
  return $groupnodes;
}

<?php
// $Id$
/**
 * @file
 * Adds calendar display themes to views.
 */

include_once('calendar_api.inc');

/**
 * Implementation of hook_help().
 */
function calendar_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Adds date calendar themes to views that can display any type of date field, and creates default calendar views.');
    case 'admin/help#calendar':
      return $output;
  }
}

/**
 *  Implementation of hook_views_style_plugins()
 */
function calendar_views_style_plugins() {
  
  $plugins = array();
  $types = calendar_view_types();
  foreach ($types as $name => $type) {
    $plugins[$name] = array(
      'name' => $type,
      'theme' => 'calendar_display',
      'summary_theme' => 'calendar_display',
      'validate' => 'views_ui_plugin_validate_table',
      'needs_fields' => TRUE,
      'needs_table_header' => FALSE,
      );
  }
  return $plugins;
}

/**
 *  Possible calendar views page display types
 */
function calendar_view_types() {
  return array('calendar' => t('Calendar'));
}

/**
 *  Identify all potential date/timestamp fields
 *  @return an array with fieldname, type, and table
 */
function calendar_fields() {
  foreach (_views_get_fields() as $name => $val) {
    $type = '';
    // for cck fields, get the date type
    if ($val['content_field']['type'] == 'date' || $val['content_field']['type'] == 'datestamp') {
      $type = $val['content_field']['type'] == 'date' ? 'cck_string' : 'cck_timestamp';
    }
    // all other fields that use the views date handler are timestamps
    elseif ($val['handler'] == views_handler_field_dates()) {
      $type = 'timestamp';
    }
    if ($type) {
      // cck fields append a column name to the field, others do not
      // need a real field_name with no column name appended for cck date formatters
      $tmp = explode('.', $name);
      $fields[$tmp[1]] = array(
        'type' => $type,
        'fullname' => $name,
        'table' => $tmp[0],
        'field' => $tmp[1],
        'field_name' => $val['content_field']['field_name'] ? $val['content_field']['field_name'] : $tmp[1],
        'query_name' => str_replace('.', '_', $name),
      );
    }
  }
  return $fields;
}

/**
 *  Calendar Views plugin theme, overrides default views theme
 */
function theme_calendar_display($view, $items, $type) {
  
  if (!is_array($items)) {
    $items = array();
  }
  
  if ($type == 'block' || $view->calendar_type == 'year') $params['mini'] = TRUE;
  
  // option to set the view by appending it after the view's other arguments
  // i.e. 2006/5/12/day will use the calendar day page type to display the items for a view
  // (assuming the view has already been created with year/month/day arguments)
  if (array_key_exists($view->args[sizeof($view->argument)], calendar_view_types())) {
    //$view->page_type = $view->args[sizeof($view->argument)];
  }
  
  $fields = calendar_fields();
  $calendar_fields = array_keys($fields);
  
  // explode out field and format info from the view
  foreach ($view->field as $data) {
    if (in_array($data['field'], $calendar_fields)) {
      $option = $fields[$data['field']];
      $start_type       = strstr($option['type'], 'string') ? 'string' : 'timestamp';
      $start_function   = strstr($option['type'], 'cck') ? 'content_format' : $data['handler'];
      $start_formatter  = $data['options'];
      $start_field      = $option['query_name'];
      $start_field_name = $option['field_name'];
    }
    if (in_array($data['field'], $calendar_fields)) {
      $option = $fields[$data['field']];
      $end_type        = strstr($option['type'], 'string') ? 'string' : 'timestamp';
      $end_function    = strstr($option['type'], 'cck') ? 'content_format' : $data['handler'];
      $end_formatter   = $data['options'];
      $end_field       = $option['query_name'];
      $end_field_name  = $option['field_name'];
    }
  }
  if ($start_function && !$end_function) {
    $end_function   = $start_function;
    $end_formatter  = $start_formatter;
    $end_field      = $start_field;
    $end_field_name = $start_field_name;
    $end_type       = $start_type;
  }
  
  // iterate through the $items array returned by the query and create date or pseudo date nodes
  
  $nodes = array();
  foreach ($items as $item) {
    $node = node_load($item->nid);
    
    // If we're dealing with an event node, go ahead and use the provided values
    if (isset($node->event_start)) $node->calendar_start = $node->event_start;
    if (isset($node->event_end)) $node->calendar_end = $node->event_end;
    if (isset($node->start_time_format)) $node->start_time_format = $node->start_time_format;
    if (isset($node->end_time_format)) $node->end_time_format = $node->end_time_format;

    if (!isset($node->calendar_start) && !isset($item->$start_field)) {
      // no date for the node and no date in the item
      // no way to display it on the calendar
      break;

    } elseif ($item->$start_field) {
      
      // if calendar_start field holds a numeric value, treat it as a unix timestamp
      // if string, convert to timestamp using strtotime
      if ($start_type == 'timestamp') {
        $node->calendar_start = $item->$start_field;
        if ($item->$end_field) {
          $node->calendar_end = $item->$end_field;
        } else {
          $node->calendar_end = $node->calendar_start;
        }
      } else {
        $node->calendar_start = strtotime($item->$start_field);
        if ($item->$end_field) {
          $node->calendar_end = strtotime($item->$end_field);
        } else {
          $node->calendar_end = $node->calendar_start;
        }
      }
      // may need to come back to this and do something better with timezone handling
      // keep it simple until things are basically working
      $node->start_offset = $timezone = _views_get_timezone();
      $node->end_offset   = $node->start_offset;
      
      if (function_exists($start_function) && $node->calendar_start) {
        if ($start_function == 'content_format') {
          // force the original value for this field into the array that content_format expects
          $node->start_time_format = content_format($start_field_name, array('value' => $item->$start_field), $start_formatter);
        }
        else {
          // or call date format function
          $node->start_time_format = $start_function(NULL, NULL, $node->calendar_start, NULL);
        }
      }
      if (function_exists($end_function) && $node->calendar_end) {
        if ($end_function == 'content_format') {
          // force the original value for this field into the array that content_format expects
          $node->end_time_format = content_format($end_field_name, array('value' => $item->$start_field), $end_formatter);
        }
        else {
          // or call date format function
          $node->end_time_format   = $end_function(NULL, NULL, $node->calendar_end, NULL);
        }
      }
      
    } else {
      // no special date field supplied in the view but there is an calendar date in the node so use it
      // no action needed
    }
    
    $nodes[$item->nid] = $node;
  }
  
  // make sure there is at least one item in $nodes to force the calendar to display
  // set the hour to 12 to minimize timezone adjustments that might push it to previous or next day
  
  if ($view->calendar_type == 'year') {
    
    // for the year view to work, must have at least one node in each month
    for ($i=1; $i<13; $i++) {
      $nodes[] = _calendar_make_node(NULL, NULL, _views_get_timezone(), $view->year, $i, 1, 12, 0);
    }
  }
  elseif (sizeof($nodes) == 0) {

    // otherwise add a blank node for the current day
    $nodes = array(_calendar_make_node(NULL, NULL, _views_get_timezone(), $view->year, $view->month, $view->day, 12, 0));

  } 
  
  if (_calendar_is_valid($view->year, 'year')) {
    
    // valid year is a test that indicates if arguments were available to establish a date for the calendar
    // a full view with an argument date will display a single month, day or week calendar page
    // with navigation that mimics regular calendar
    
    // trim off date values that are outside the selected range to prevent display of incomplete extra calendars
    $nodes = _calendar_limit_nodes($nodes, $view->page_type, $view->year, $view->month, $view->day, $view->week, _views_get_timezone());
    
    // hide the intermediate header rows created by the event api and
    // push title and navigation into calendar header 
    $params['hide_header'] = true;
    $title = theme('table', calendar_nav($view, $params['mini']), array());
    
    // standard api displays a whole month instead of a single week
    // adjust here for single week display
    if ($view->page_type == 'week' && $view->week) {
      $params['force_week'] = $view->week;
    }
  
  } else {
    
    // if this is a summary page or any view that doesn't use arguments
    // view results may contain multiple calendar months, days or weeks
    // the standard calendar api (not using the $params and $title above)
    // will display multiple calendar months, weeks, or days with no navigation
    // make no change to api, just set title
    $title = $view->subtitle ? $view->subtitle : $view->page_type;
  }
  
  // use calendar_get_calendar api to draw the calendar
  theme_add_style(drupal_get_path('module', 'calendar') .'/calendar.css');
  
  $params['url'] = $view->url;
  return calendar_get_calendar($view->calendar_type, $nodes, 'calendar', $title, $params);
  
}

/**
 *  Function to construct back and next navigation from views arguments
 */
function calendar_nav($view, $mini = FALSE) {
  if (!_calendar_is_valid($view->year, 'year')) {
    return $view->subtitle;
  }

  if (_calendar_is_valid($view->week, 'week')) {
    $timezone = _views_get_timezone();
    $cur_stamp = strtotime('Jan 1, '.$view->year.' + '.intval($view->week).' weeks GMT') - $timezone;
  } else {
    $cur_stamp = gmmktime(0, 0, 0, ($view->month ? $view->month : 1), ($view->day ? $view->day : 1), ($view->year ? $view->year : gmdate("Y", time())));
  }
  
  // make the navigation into a header, with prev and next links
  // use the calendar_nav themes to mimic standard calendar navigation
  $paths = calendar_get_paths($cur_stamp, $view);
  $prev_path = implode('/', array_reverse($paths[0]));
  $next_path = implode('/', array_reverse($paths[1]));
  
  $header = array();
  $header[]  = array('data' => theme('calendar_nav_prev', $prev_path, $mini ? FALSE : TRUE), 'class' => 'prev');
  $header[]  = array('data' => $view->subtitle, 'class' => 'heading', 'colspan' => 5);
  $header[]  = array('data' => theme('calendar_nav_next', $next_path, $mini ? FALSE : TRUE), 'class' => 'next');
  
  return $header;
}

function calendar_get_paths($cur_stamp, $view) {
  $path = array();
  
  // build an array of the current path and its parts
  $i = 0;
  $path[$i]     = array(
    'path' => $view->url,
    'type' => 'url',
      );
  foreach ($view->argument as $delta => $arg) {
    if ($view->args[$delta]) {
      $i++;
      $pathtype = str_replace('calendar_', '', $arg['type']);
      $path[$i] = array(
        'path' => $view->$pathtype,
        'type' => $pathtype,
        );
    }
  }
  
  // if there are other arguments after the view arguments, add them to the navigation links
  while($i < sizeof($view->args)) {
    $i++;
    $path[$i] = array(
      'path' => $view->args[intval($i - 1)],
      'type' => '',
    );
  }
  
  // reverse through the path, creating a $nextpath and $prevpath arrays
  for ($x = $i; $x >= 0; $x--) {
    switch ($path[$x]['type']) {
    case ('day'):
      $day = $path[$x]['path'];
      $next_stamp = $cur_stamp + (86400);
      $prev_stamp = $cur_stamp - (86400);
      $nextpath[$x] = gmdate('j', $next_stamp);
      $prevpath[$x] = gmdate('j', $prev_stamp);
      break;
    case ('week'):
      $week = $path[$x]['path'];
      $year = $view->year;
      if (!$next_stamp) {
        $next_stamp = $cur_stamp + (604800);
        $prev_stamp = $cur_stamp - (604800);
      }
      $nextpath[$x] = gmdate('W', $next_stamp);
      $prevpath[$x] = gmdate('W', $prev_stamp);
      break;
    case ('month'):
      $month = $path[$x]['path'];
      $year  = $view->year;
      if (!$next_stamp) {
        $next_stamp = gmmktime(0, 0, 0, ($month < 12 ? $month + 1 : 1), 1, ($month < 12 ? $year : $year + 1));
        $prev_stamp = gmmktime(0, 0, 0, ($month > 1  ? $month - 1 : 12), 1, ($month > 1 ? $year : $year - 1));
      }
      $nextpath[$x] = gmdate('n', $next_stamp);
      $prevpath[$x] = gmdate('n', $prev_stamp);
      break;
    case ('year'):
      $year = $view->year;
      if (!$next_stamp) {
        $next_stamp = gmmktime(0, 0, 0, 1, 1, ($year + 1));
        $prev_stamp = gmmktime(0, 0, 0, 12, 1, ($year - 1));
      }
      $nextpath[$x] = gmdate('Y', $next_stamp);
      $prevpath[$x] = gmdate('Y', $prev_stamp);
      break;
    default:
      // all other arguments are just passed through
      $nextpath[$x] = $path[$x]['path'];
      $prevpath[$x] = $path[$x]['path'];
      break;
    }
  }
  
  return array($prevpath, $nextpath);

}

/**
 *  A function to create a blank date to force a calendar display when there is no data
 */
function _calendar_make_node($node = NULL, $timestamp = NULL, $offset = NULL, $year = NULL, $month = NULL, $day = NULL, $hour = NULL, $minute = NULL) {
  
  $offset = $offset ? $offset : _views_get_timezone();
    
  if (!$timestamp) {
    $year   = _calendar_is_valid($year, 'year')     ? $year   : gmdate('Y', time());
    $month  = _calendar_is_valid($month, 'month')   ? $month  : gmdate('m', time());
    $day    = _calendar_is_valid($day, 'day')       ? $day    : gmdate('j', time());
    $hour   = _calendar_is_valid($hour, 'hour')     ? $hour   : gmdate('H', time());
    $minute = _calendar_is_valid($minute, 'minute') ? $minute : gmdate('i', time());
    $timestamp = gmmktime($hour, $minute, 0, $month, $day, $year);
  }
  
  if (!$node) {
    $node = new stdClass();
    $node->nid = 0;
  }

  $node->calendar_start = $timestamp;
  $node->start_offset   = $offset;
  $node->calendar_end   = $timestamp;
  $node->end_offset     = $offset;
  
  return $node;
}

/**
 *  A function to adjust node values to slice off times before and after the selected view
 *  used for calendars that span days, months, or years since the calendar api
 *  automatically creates additional calendars for calendars that extend into another time period
 *  and the additional calendars will be incomplete (only containing cross-over calendars)
 */
function _calendar_limit_nodes($nodes, $type, $year, $month, $day, $week, $offset) {
  
  switch ($type) {
  case ('day'):
    $min_date = gmmktime(0, 0, 0, $month, $day, $year);
    $max_date = $min_date;
    break;
  case ('week'):
    // use strtotime to find first day of requested week
    $min_date = strtotime('Jan 1, '.$year.' + '.intval($week - 1).' weeks');
    $max_date = $min_date + (604800);
    break;
  case ('month');
    $min_date = gmmktime(0, 0, 0, $month, 1, $year);
    // find the first day of the next month and subtract one day
    if ($month < 12) {
      $max_date = gmmktime(0, 0, 0, intval($month + 1), 1, $year) - (86400);
    } else {
      $max_date = gmmktime(0, 0, 0, 1, 1, intval($year + 1)) - (86400);
    }
    break;
  }
  
  foreach ($nodes as $nid => $node) {
    
    // store real calendar start and end dates to swap back in before displaying the node
    $nodes[$nid]->real_start = $node->calendar_start;
    $nodes[$nid]->real_end   = $node->calendar_end;
    
    // change calendar_start and calendar_end to cut off node values outside the current range
    // this will keep calendar api from rendering incomplete calendars for those values
    if ($node->calendar_start < $min_date ) $nodes[$nid]->calendar_start = $min_date;
    if ($node->calendar_end   > $max_date ) $nodes[$nid]->calendar_end   = $max_date; 
  }
  
  return $nodes;

}

/**
 *  Implementation of hook_calendar_node() from the calendar_get_calendar() api
 *  calendar api is expecting a function for each calendar type but
 *  all of them need the same processing, so run them through a single function
 *  instead of duplicating the processing for each one
 */
function calendar_node_month($node) {
  return calendar_node($node, 'month');
}
function calendar_node_day($node) {
  return calendar_node($node, 'day');
}
function calendar_node_week($node) {
  return calendar_node($node, 'week');
}
function calendar_node($node, $type) {
  // restore real calendar start and end times if they were adjusted to limit calendar range
  if ($node->real_start) $node->calendar_start = $node->real_start;
  if ($node->real_end)   $node->calendar_end   = $node->real_end;

  if ($node->nid > 0 && $node->calendar_start) {
    // this is a real calendar, go ahead and display it
    return theme('calendar_node', $type, $node);
  
  } else {
    // surpress display of psuedo calendars added to force display of a blank calendar
    // have to return some value for blank day so not overridden by normal calendar node theme
    // a blank space seems to be sufficient to do that
    return ' ';
  }
}

/**
 *  Implementation of hook_views_arguments()
 */
function calendar_views_arguments() {
  $arguments = array(
    'calendar_year' => array(
      'name' => t('Calendar: Year'),
      'handler' => 'calendar_handler_arg_year',
      'help' => t('Filter by the calendar year (YYYY).'),
    ),
    'calendar_month' => array(
      'name' => t('Calendar: Month'),
      'handler' => 'calendar_handler_arg_month',
      'help' => t("Filter by the calendar month (1-12). Place this argument after a 'Year' argument."),
    ),
    'calendar_day' => array(
      'name' => t('Calendar: Day'),
      'handler' => 'calendar_handler_arg_day',
      'help' => t("Filter by the calendar day (1-31). Place this argument after a 'Year' and a 'Month' argument."),
    ),
    'calendar_week' => array(
      'name' => t('Calendar: Week'),
      'handler' => 'calendar_handler_arg_week',
      'help' => t("Filter by the week number (1-52). Place this argument after a 'Year' argument."),
    ),
  );
  return $arguments;
}

/**
 *  Custom views handlers for the calendars arguments
 */

function calendar_handler_arg_year($op, &$query, $argtype, $arg = '') {
  return calendar_handler_arg_type($op, $query, $argtype, $arg, 'calendar_year', 'YEAR');
}
function calendar_handler_arg_month($op, &$query, $argtype, $arg = '') {
  return calendar_handler_arg_type($op, $query, $argtype, $arg, 'calendar_month', 'MONTH');
}
function calendar_handler_arg_day($op, &$query, $argtype, $arg = '') {
  return calendar_handler_arg_type($op, $query, $argtype, $arg, 'calendar_day', 'DAY');
}
function calendar_handler_arg_week($op, &$query, $argtype, $arg = '') {
  return calendar_handler_arg_type($op, $query, $argtype, $arg, 'calendar_week', 'WEEK');
}
function calendar_handler_arg_type($op, &$query, $argtype, $arg, $field_name, $field_type) {

  // arguments don't actually do anything except tell us what period we're in
  // and make sure views knows that a page with this argument must be processed by views
  // the individual argument provides too little info to set up filters
  // filtering is done in hook_query_alter since we don't have complete view info until then
  
  $query->field_name[] = $field_name;
  $query->field_type[] = $field_type;
  $query->field_args[] = $arg;
  return;
}

/**
 *  Implementation of hook_views_query()
 *  Insert filters into the query based on the current calendar view and the selected fields
 */
function calendar_views_query_alter(&$query, &$view) {
  
  // make sure block views default to the current month
  // and never try to show the day

  if ($view->build_type == 'block') {
    $view->calendar_type = 'month';
    $view->args = (explode('/', str_replace($view->url .'/', '', $view->real_url)));
    foreach ($view->argument as $delta => $argument) {
      if ($argument['type'] == 'calendar_month' && !$view->args[$delta]) {
        $view->args[$delta] = gmdate('m', time());
      }
      elseif ($argument['type'] == 'calendar_day') {
        unset($view->args[$delta]);
      }
    }
  }
  
  foreach ($view->argument as $delta => $argument) {
    
    // there might be non-calendar arguments in the view, so we must ignore those
    
    if (in_array($argument['type'], array('calendar_year', 'calendar_month', 'calendar_day', 'calendar_week'))) {
      
      // make sure 'display all values' is selected for the calendar arguments
      // summary views are meaningless and create errors in this context
      $view->argument[$delta]['argdefault'] = 2;

      if ($argument['type'] == 'calendar_year') {
        $view->year = _calendar_is_valid($view->args[$delta], 'year') ? $view->args[$delta] : gmdate('Y', time());
        $query_min = $view->year;
        $query_max = $view->year;
        $next_min = '-01';
        $next_max = '-12';
        $view->subtitle = l($view->year, $view->url .'/'. $view->year);
        // make sure we have at least a year available as an argument
        if (!$view->args[$delta]) {
          $view->args[$delta] = $view->year;
        }
        $view->calendar_type = str_replace('calendar_', '', $argument['type']);
      }
      if ($argument['type'] == 'calendar_month' && $view->args[$delta]) {
        $view->month = _calendar_is_valid($view->args[$delta], 'month') ? $view->args[$delta] : gmdate('m', time());
        $query_min .= '-'. sprintf('%02d', $view->month);
        $query_max .= '-'. sprintf('%02d', $view->month);
        $next_min = '-01';
        $next_max = '-31';
        // use the second day of the month because gm functions sometimes return the previous month
        $format = $view->build_type == 'block' || $view->calendar_type == 'year' ? 'M Y' : 'F Y';
        $iso = $view->year .'-'. sprintf('%02d', $view->month) .'-02';
        $view->subtitle = l(gmdate($format, strtotime($iso)), $view->url .'/'. $view->year .'/'. $view->month);
        $view->calendar_type = str_replace('calendar_', '', $argument['type']);
      }
      if ($argument['type'] == 'calendar_day' && $view->args[$delta]) {
        $view->day = _calendar_is_valid($view->args[$delta], 'day') ? $view->args[$delta] : gmdate('d', time());
        $query_min .= '-'. sprintf('%02d', $view->day);
        $query_max .= '-'. sprintf('%02d', $view->day);
        $next_min = 'T00:00:00';
        $next_max = 'T23:59:59';
        $iso = $view->year .'-'. sprintf('%02d', $view->month) .'-'. sprintf('%02d', $view->day) .'T12:00:00';
        $view->subtitle = l(gmdate('l, F j Y', strtotime($iso)), $view->url .'/'. $view->year .'/'. $view->month .'/'. $view->day);
        $view->calendar_type = str_replace('calendar_', '', $argument['type']);
      }
      if ($argument['type'] == 'calendar_week' && $view->args[$delta]) {
        $view->week = _calendar_is_valid($view->args[$delta], 'week') ? $view->args[$delta] : 1;
        $query_min .= '-'. $view->week;
        $query_max .= '-'. $view->week;
        $next_min = '';
        $next_max = '';
        // use strtotime to find first day of requested week
        $week  = $view->args[$delta];
        $view->week = $week;
        $date = strtotime('Jan 1, '.$year.' + '.intval($week - 1).' weeks');
        $view->subtitle = l(t("Week of %date", array('%date' => gmdate('F j Y', $date))), $view->url .'/'. $view->year .'/'. $view->week);
        $view->calendar_type = str_replace('calendar_', '', $argument['type']);
      }
    }
  }
  
  $query_min .= $next_min;
  $query_max .= $next_max;
  
  $query_timestamp_min = strtotime($query_min);
  $query_timestamp_max = strtotime($query_max);
  
  $query_min .= '%';
  $query_max .= '%';
  
  // find all datetime fields in this view and add filters for them to the query
  $fields = calendar_fields();
  foreach ($view->field as $field) {
    if ($fields[$field['field']]['type'] == 'cck_string') {
      $queries[] = "(". $field['fullname'] .">='$query_min' AND ". $field['fullname'] ."<='$query_max')";
    }
    elseif (strstr($fields[$field['field']]['type'], 'timestamp')) {
      $queries[] = "(". $field['fullname'] .">='$query_timestamp_min' AND ". $field['fullname'] ."<='$query_timestamp_max')";
    }
  }
  $query->add_where(implode(" OR ", $queries));
  
  return;

}

function calendar_now() {
  return gmmktime(0, 0, 0, gmdate('m', time()), gmdate('j', time()), gmdate('Y', time()));
}

/**
 *  Implementation of hook_views_pre_view()
 */
function calendar_views_pre_view(&$view, &$items) {

  // add this so empty calendar results will produce blank calendar page
  // needed for smooth prev/next transitions and to make sure at least
  // a blank calendar is displayed in calendar block
  if (array_key_exists($view->page_type, calendar_view_types())) {
    if (!$items && $view->build_type == 'page' && $view->year) {
      $view->page_empty .= theme('calendar_display', $view, array(), 'page');
      $view->page_empty_format = 3;
    }
    if (!$items && $view->build_type == 'block' && $view->year) {
      $view->block_empty .= theme('calendar_display', $view, array(), 'block');
      $view->block_empty_format = 3;
    }
  }
  if ($view->build_type == 'page') {
    $calendar_links = array(
      l(t('Year'), $view->url .'/'. $view->year),
      l(t('Month'), $view->url .'/'. $view->year .'/'. ($view->month ? $view->month : gmdate('m', calendar_now()))),
      l(t('Day'), $view->url .'/'. $view->year .'/'. ($view->month ? $view->month : gmdate('m', calendar_now())) .'/'. ($view->day ? $view->day : gmdate('j', calendar_now()))),
      );
    return '» '. theme('links', $calendar_links);
  }
  return;
}

/**
 *  A function to test the validity of various date parts
 */
function _calendar_is_valid($value, $type) {
  
  $value = intval($value);
  if ($value <= 0) return false;
  switch ($type) {
  case ('year'):
    if ($value < 1970) return false;
    break;
  case ('month'):
    if ($value < 0 || $value > 12) return false;
    break;
  case ('day'):
    if ($value < 0 || $value > 31) return false;
    break;
  case ('week'):
    if ($value < 0 || $value > 53) return false;
  }
  return true;
}

function calendar_views_default_views() {
$view = new stdClass();
  $view->name = 'calendar';
  $view->description = 'Calendar view of any date field';
  $view->access = array ();
  $view->view_args_php = '';
  $view->page = TRUE;
  $view->page_title = 'Calendar';
  $view->page_header = "";
  $view->page_header_format = '1';
  $view->page_footer = "";
  $view->page_footer_format = '1';
  $view->page_empty = "";
  $view->page_empty_format = '1';
  $view->page_type = 'calendar';
  $view->url = 'calendar';
  $view->use_pager = TRUE;
  $view->nodes_per_page = '99';
  $view->block = TRUE;
  $view->block_title = '';
  $view->block_header = "";
  $view->block_header_format = '1';
  $view->block_footer = "";
  $view->block_footer_format = '1';
  $view->block_empty = "";
  $view->block_empty_format = '1';
  $view->block_type = 'calendar';
  $view->nodes_per_block = '99';
  $view->block_more = '1';
  $view->block_use_page_header = FALSE;
  $view->block_use_page_footer = FALSE;
  $view->block_use_page_empty = FALSE;
  $view->sort = array (
    array (
      'tablename' => 'node',
      'field' => 'changed',
      'sortorder' => 'ASC',
      'options' => '',
    ),
  );
  $view->argument = array (
    array (
      'type' => 'calendar_year',
      'argdefault' => '2',
      'title' => 'Year',
      'options' => '',
      'wildcard' => '',
      'wildcard_substitution' => '',
    ),
    array (
      'type' => 'calendar_month',
      'argdefault' => '2',
      'title' => 'Month',
      'options' => '',
      'wildcard' => '',
      'wildcard_substitution' => '',
    ),
    array (
      'type' => 'calendar_day',
      'argdefault' => '2',
      'title' => 'Day',
      'options' => '',
      'wildcard' => '',
      'wildcard_substitution' => '',
    ),
  );
  $view->field = array (
    array (
      'tablename' => 'node',
      'field' => 'title',
      'label' => 'Title:',
      'handler' => 'views_handler_field_nodelink',
      'options' => 'link',
    ),
    array (
      'tablename' => 'node',
      'field' => 'changed',
      'label' => 'Updated:',
      'handler' => 'views_handler_field_date_small',
    ),
  );
  $view->filter = array (
    array (
      'tablename' => 'node',
      'field' => 'status',
      'operator' => '=',
      'options' => '',
      'value' => '1',
    ),
  );
  $view->exposed_filter = array (
  );
  $view->requires = array(node);
  $views[$view->name] = $view;
  return $views;
}

/**
 *  Make sure both views and calendar are enabled
 * hunmonk's module dependency check: see http://drupal.org/node/54463
 */
function calendar_form_alter($form_id, &$form) {
  if ($form_id == 'system_modules' && !$_POST) {
    calendar_system_module_validate($form);
  }
}

/**
 * hunmonk's module dependency check: see http://drupal.org/node/54463
 */
function calendar_system_module_validate(&$form) {
  $module = 'calendar';
  $dependencies = array('views');
  foreach ($dependencies as $dependency) {
      if (!in_array($dependency, $form['status']['#default_value'])) {
        $missing_dependency = TRUE;
        $missing_dependency_list[] = $dependency;
      }
  }
  if (in_array($module, $form['status']['#default_value']) && isset($missing_dependency)) {
    db_query("UPDATE {system} SET status = 0 WHERE type = 'module' AND name = '%s'", $module);
    $key = array_search($module, $form['status']['#default_value']);
    unset($form['status']['#default_value'][$key]);
    drupal_set_message(t('The module %module was deactivated--it requires the following disabled/non-existant modules to function properly: %dependencies', array('%module' => $module, '%dependencies' => implode(', ', $missing_dependency_list))), 'error');
  }
}
